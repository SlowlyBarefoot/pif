#include "core/pif_log.h"
#include "sensor/pif_bmi270.h"

#include <math.h>


/*! @name  Global array that stores the configuration file of BMI270 */
const uint8_t maximum_fifo_config_file[] = {
    0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x1a, 0x00, 0xc8, 0x2e, 0x00, 0x2e, 0xc8, 0x2e, 0x00, 0x2e, 0xc8, 0x2e, 0x00,
    0x2e, 0xc8, 0x2e, 0x00, 0x2e, 0xc8, 0x2e, 0x00, 0x2e, 0xc8, 0x2e, 0x00, 0x2e, 0x90, 0x32, 0x21, 0x2e, 0x59, 0xf5,
    0x10, 0x30, 0x21, 0x2e, 0x6a, 0xf5, 0x1a, 0x24, 0x22, 0x00, 0x80, 0x2e, 0x3b, 0x00, 0xc8, 0x2e, 0x44, 0x47, 0x22,
    0x00, 0x37, 0x00, 0xa4, 0x00, 0xff, 0x0f, 0xd1, 0x00, 0x07, 0xad, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x11, 0x24, 0xfc, 0xf5, 0x80, 0x30, 0x40, 0x42, 0x50, 0x50, 0x00, 0x30, 0x12, 0x24, 0xeb,
    0x00, 0x03, 0x30, 0x00, 0x2e, 0xc1, 0x86, 0x5a, 0x0e, 0xfb, 0x2f, 0x21, 0x2e, 0xfc, 0xf5, 0x13, 0x24, 0x63, 0xf5,
    0xe0, 0x3c, 0x48, 0x00, 0x22, 0x30, 0xf7, 0x80, 0xc2, 0x42, 0xe1, 0x7f, 0x3a, 0x25, 0xfc, 0x86, 0xf0, 0x7f, 0x41,
    0x33, 0x98, 0x2e, 0xc2, 0xc4, 0xd6, 0x6f, 0xf1, 0x30, 0xf1, 0x08, 0xc4, 0x6f, 0x11, 0x24, 0xff, 0x03, 0x12, 0x24,
    0x00, 0xfc, 0x61, 0x09, 0xa2, 0x08, 0x36, 0xbe, 0x2a, 0xb9, 0x13, 0x24, 0x38, 0x00, 0x64, 0xbb, 0xd1, 0xbe, 0x94,
    0x0a, 0x71, 0x08, 0xd5, 0x42, 0x21, 0xbd, 0x91, 0xbc, 0xd2, 0x42, 0xc1, 0x42, 0x00, 0xb2, 0xfe, 0x82, 0x05, 0x2f,
    0x50, 0x30, 0x21, 0x2e, 0x21, 0xf2, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0xf0, 0x6f, 0x02, 0x30, 0x02, 0x42, 0x20,
    0x26, 0xe0, 0x6f, 0x02, 0x31, 0x03, 0x40, 0x9a, 0x0a, 0x02, 0x42, 0xf0, 0x37, 0x05, 0x2e, 0x5e, 0xf7, 0x10, 0x08,
    0x12, 0x24, 0x1e, 0xf2, 0x80, 0x42, 0x83, 0x84, 0xf1, 0x7f, 0x0a, 0x25, 0x13, 0x30, 0x83, 0x42, 0x3b, 0x82, 0xf0,
    0x6f, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x12, 0x40, 0x52, 0x42, 0x00, 0x2e, 0x12, 0x40, 0x52, 0x42, 0x3e, 0x84,
    0x00, 0x40, 0x40, 0x42, 0x7e, 0x82, 0xe1, 0x7f, 0xf2, 0x7f, 0x98, 0x2e, 0x6a, 0xd6, 0x21, 0x30, 0x23, 0x2e, 0x61,
    0xf5, 0xeb, 0x2c, 0xe1, 0x6f
};


BOOL pifBmi270_Config(PifBmi270* p_owner, PifId id, PifImuSensor* p_imu_sensor)
{
	if (!p_owner || !p_imu_sensor || !p_owner->_fn.p_device
			|| !p_owner->_fn.read_byte || !p_owner->_fn.read_bytes || !p_owner->_fn.read_bit
			|| !p_owner->_fn.write_byte || !p_owner->_fn.write_bytes || !p_owner->_fn.write_bit) {
		pif_error = E_INVALID_PARAM;
    	return FALSE;
	}

    // Perform a soft reset to set all configuration to default
    // Delay 100ms before continuing configuration
	if (!(p_owner->_fn.write_byte)(p_owner->_fn.p_device, BMI270_REG_CMD, BMI270_C_CMD_SOFT_RESET)) return FALSE;
	pif_Delay1ms(100);

	if (id == PIF_ID_AUTO) id = pif_id++;
    p_owner->_id = id;
	p_owner->temp_scale = 1;
	p_owner->__p_imu_sensor = p_imu_sensor;

	p_imu_sensor->_measure |= IMU_MEASURE_GYROSCOPE | IMU_MEASURE_ACCELERO;

	p_imu_sensor->__gyro_info.align = IMUS_ALIGN_CW0_DEG;
	p_imu_sensor->__gyro_info.read = (PifImuSensorRead)pifBmi270_ReadGyro;
	p_imu_sensor->__gyro_info.p_issuer = p_owner;

	p_imu_sensor->__accel_info.align = IMUS_ALIGN_CW0_DEG;
	p_imu_sensor->__accel_info.read = (PifImuSensorRead)pifBmi270_ReadAccel;
	p_imu_sensor->__accel_info.p_issuer = p_owner;

    // Reset calibrate values
    p_imu_sensor->__delta_gyro[AXIS_X] = 0;
    p_imu_sensor->__delta_gyro[AXIS_Y] = 0;
    p_imu_sensor->__delta_gyro[AXIS_Z] = 0;
    p_imu_sensor->__use_calibrate = FALSE;

    // Reset threshold values
    p_imu_sensor->__threshold_gyro[AXIS_X] = 0;
    p_imu_sensor->__threshold_gyro[AXIS_Y] = 0;
    p_imu_sensor->__threshold_gyro[AXIS_Z] = 0;
    p_imu_sensor->__actual_threshold = 0;
    return TRUE;
}

BOOL pifBmi270_UploadConfig(PifBmi270 *p_owner)
{
    if (!(p_owner->_fn.write_byte)(p_owner->_fn.p_device, BMI270_REG_PWR_CONF, 0)) return FALSE;
	pif_Delay1ms(1);
    if (!(p_owner->_fn.write_byte)(p_owner->_fn.p_device, BMI270_REG_INIT_CTRL, 0)) return FALSE;
	pif_Delay1ms(1);

    // Transfer the config file
    if (!(p_owner->_fn.write_bytes)(p_owner->_fn.p_device, BMI270_REG_INIT_DATA, (uint8_t *)maximum_fifo_config_file, sizeof(maximum_fifo_config_file))) return FALSE;
    pif_Delay1ms(10);

    if (!(p_owner->_fn.write_byte)(p_owner->_fn.p_device, BMI270_REG_INIT_CTRL, 1)) return FALSE;
	pif_Delay1ms(1);
	return TRUE;
}

BOOL pifBmi270_ReadGyro(PifBmi270* p_owner, int16_t* p_gyro)
{
	uint8_t data[6];

	if (!(p_owner->_fn.read_bytes)(p_owner->_fn.p_device, BMI270_REG_GYR_X_LSB, data, 6)) return FALSE;

	p_gyro[AXIS_X] = *(uint16_t *)data;
	p_gyro[AXIS_Y] = *(uint16_t *)(data + 2);
	p_gyro[AXIS_Z] = *(uint16_t *)(data + 4);
	if (p_owner->gyro_scale > 0) {
		p_gyro[AXIS_X] /= p_owner->gyro_scale;
		p_gyro[AXIS_Y] /= p_owner->gyro_scale;
		p_gyro[AXIS_Z] /= p_owner->gyro_scale;
	}
	return TRUE;
}

BOOL pifBmi270_ReadAccel(PifBmi270* p_owner, int16_t* p_accel)
{
	uint8_t data[6];

    if (!(p_owner->_fn.read_bytes)(p_owner->_fn.p_device, BMI270_REG_ACC_X_LSB, data, 6)) return FALSE;

	p_accel[AXIS_X] = *(uint16_t *)data;
	p_accel[AXIS_Y] = *(uint16_t *)(data + 2);
	p_accel[AXIS_Z] = *(uint16_t *)(data + 4);
	if (p_owner->accel_scale > 0) {
		p_accel[AXIS_X] /= p_owner->accel_scale;
		p_accel[AXIS_Y] /= p_owner->accel_scale;
		p_accel[AXIS_Z] /= p_owner->accel_scale;
	}
	return TRUE;
}

BOOL pifBmi270_ReadTemperature(PifBmi270* p_owner, int16_t* p_temperature)
{
	uint8_t data[2];
    const int16_t RoomTemp_Offset = 21;
    const int16_t Temp_Sensitivity = 333.87;

    if (!(p_owner->_fn.read_bytes)(p_owner->_fn.p_device, BMI270_REG_TEMPERATURE_LSB, data, 2)) return FALSE;
    *p_temperature = (RoomTemp_Offset + (*(int16_t *)data - RoomTemp_Offset) / Temp_Sensitivity) * p_owner->temp_scale;
	return TRUE;
}
